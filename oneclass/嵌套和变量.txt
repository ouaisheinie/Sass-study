<link type = "stylesheet" href="style/index.css">  这个是对的  CSS文件可以这样引用  但是sass 文件就不能这样引用了

<link type = "stylesheet" href="style/index.scss">
<link type = "stylesheet" href="style/index.scss">  这样引用sass 文件就是错的

在HTML文件里引用sass  需要先编译   先把sass 编译成css   然后 在html中引用

编译可以用  命令行工具   也可以用第三方软件   vscode 可以   


1. 安装sass   先安装ruby   目前选择在windows下    在命令行  sass -v  查看电脑是否安装sass

2.编译工具 
    1.命令行编译
    //单文件转换命令
    sass input.scss output output.css
    //单文件监听命令
    sass --watch input.scss:output.css
    //如果你有很多的sass文件的目录，你也可以告诉sass 监听整个目录
    sass --watch app/sass:public/stylesheets
    
    2.图形化编译   运用考拉来编译

    3.webstrom 的 file watcher   或者  VSCode的编译插件

3. sass 和 scss
    开发的时候 更推荐用scss  更接近css

4.变量
    sass里  变量以美元符号$来开头

5.编译错误
    sass或者scss 文件里  是默认utf-8编码    但是里面有中文字符  也会引起编译错误

6.sass不同样式风格的输出方法
    1.嵌套输出方式 nested
        1.sass提供了一种嵌套显示CSS文件的方法
                nav{
                    ul{
                        margin:0;
                        padding:0;
                        list-style:one;
                    }
                    li{display:inline-block;}
                    a{
                        display:block;
                        padding:6px 12px;
                        text-decoration:none;
                    }
                }

        -----上面的代码 编译的时候 带上参数 --style nested
        sass --watch test.scss:test.css --style nested
        编译出来就是如下

                nav ul {
                    margin: 0;
                    padding: 0;
                    list-style: none; }
                nav li {
                    display: inline-block; }
                nav a {
                    display: block;
                    padding: 6px 12px;
                    text-decoration: none; }
    2.展开输出方式 expanded
        跟上面输出一样   只是展开后 每个类的后面的"}"换到下一行了

            nav ul {
                    margin: 0;
                    padding: 0;
                    list-style: none; 
                    }
            nav li {
                    display: inline-block; 
                    }
            nav a{
                    display: block;
                    padding: 6px 12px;
                    text-decoration: none; 
                }
    2.紧凑输出方式 compact
        nav ul { margin: 0; padding: 0; list-style: none; }
        nav li { display: inline-block; }
        nav a { display: block; padding: 6px 12px; text-decoration: none; }
    4.压缩输出方式 compressed
        nav ul{margin:0;padding:0;list-style:none}nav li{display:inline-block}nav a{display:block;padding:6px 12px;text-decoration:none}


7.sass中的声明变量
    1.生命变量用美元符号$
    2.变量名称
    3.赋予变量的值
    4.!default 表示默认值  例如 $btn-primary-color:#fff !default;

8.普通变量与默认变量
    1.普通变量  定义之后可以在全局范围内使用
    $fontSize:12px;
    body{
        font-size:$fontSize;
    }

    2.默认变量 sass的默认变量仅需要在值后面加上!default即可
    $baseLineHeight:1.5 !default;
    body{
        line-height:$baseLineHeight;
    }
        1.默认变量的覆盖
        只需要在默认变量之前重新定义一下  例如
        $baseLineHeight: 2;
        $baseLineHeight: 1.5 !default;
        body{
            line-height: $baseLineHeight; 
        }
    ！！！！！默认变量的价值在进行组件化开发的时候非常有用。

9.sass变量的调用
    1.sass变量在声明之后 就可以在需要的地方调用变量了  调用变量的方法也非常简单
    就是类似之前我们一直都在调用着用了  哈哈哈哈

10.局部变量和全局变量
    sass里变量的作用在过去几年已经发生了一些改变。知道最近，规则集和其他范围内生命变量的作用于才被默认为本地。如果已经存在同名的全局变量，从3.4版本开始。sass已经可以正确处理作用域的概念，并通过创建一个新的局部变量来代替。
    例子：
    //scss
    $color:orange !default;
    //定义全局变量(在选择器，函数，混合宏..的外面定义的变量为全局变量)
    .block{
        color:$color;//调用全局变量
    }
    em{
        $color:red;//定义局部变量
        a{
            color:$color;调用的局部变量
        }
    }
    span{
        color:$color;//的调用的全局变量
    }

    sass还提供一个!global参数  
    !global 和 !default对于定义变量都是很有帮助的。
    我们之后将会详细介绍这两个参数的使用以及其功能。

    全局变量的影子
    当在局部范围(选择期内,函数内,混合宏内...)生命一个已经存在的全局范围内的变量时，局部变量变量就成为了全局变量的影子。“基本上，局部变量只会在局部范围内覆盖全局变量。”

    什么时候声明变量？
    创建变量只适用于感觉确有必要的情况下。不要为了某些骇客行为而声明变量，这些丝毫没有作用。只有满足所有下述标准时方可创建新变量：
        1.该值至少重复出现两次；
        2.该值至少可能会被更新一次；
        3.该值所有的表现都与变量有关(非巧合);
    基本上没有理由声明一个永远不需要更新或者只在单一地方使用的变量。

11.sass嵌套  选择器嵌套
    1.sass中也提供了选择器嵌套功能，但也并不意味着你在sass中的嵌套是无节制的，因为你嵌套的层级越深，编译出来的CSS代码的选择器层级将越深，这往往是大家不愿意看到的一点，这个特性正在被众多开发者滥用。

    2.选择器嵌套的样式表的作者提供了一个通过局部选择器互相嵌套实现全局选择的方法，Sass的嵌套分为三种：
        1.选择器嵌套
        2.属性嵌套
        3.伪类嵌套
    3.嵌套结构钟的 "&" 符号 代表当前作用于的嵌套集

12.sass嵌套  属性嵌套
    sass钟海提供属性嵌套:css有一些属性前缀相同，只是后缀不一样,比如border-top/border-right,与这个类似的还有margfin,padding,font等属性，假设你的样式中用到了
    .box{
        border-top:1px solid red;
        border-bottom:1px solid green;
    }
    在Sass中，我们可以把上面的代码这样写
    .box{
        border:{
            top:1px solid red;
            bottom:1px solid green;
        }
    }

13.sass嵌套  伪类嵌套
    1.其实伪类嵌套和属性嵌套非常类似，只不过它需要借助符号 "&"符号一起配合使用。我们就拿经典的clearfix为例
    .clearfix{
        $:before,
        $:after{
            content:"";
            display:table;
        }
        $:after{
            clear:both;
            overflow:hidden;
        }
    }
    上面的代码编译出来的CSS 为
    .clearfix:before,.clearfix:after{
        content:"";
        display:tabel;
    }
    .clearfix:after{
        clear:both;
        overflow:hidden;
    }
    但是我们应该避免选择器嵌套   显然 只有少数情况适应这一措施

14.混合宏 声明混合宏
    如果整个网站中有基础小样式类似，比如颜色或者字体等。在Sass可以使用变量来统一初六，那么这种选择还是不错的。当然你的样式越变越复杂，需要重复使用大段的样式时，使用变量就无法达到完美的目的了，这个时候Sass钟的混合宏就会变得非常有意义。
    下面主要介绍Sass中的混合宏

    1.声明混合宏
        不带参数混合宏
        在Sass中，使用"@mixin"来声明一个混合宏。如：
        @mixin border-radius{
            -webkit-border-radius:5px;
            border-radius:5px;
        }
        其中 @mixin 是用来声明混合宏的关键词,有点类似Css中的@media，@font-face一样。border-radius是混合宏的名称，大括号里面是复用的样式代码。

    2.带参数的混合宏
        1.除了声明一个不带参数的混合宏之外，还可以在定义混合宏时带有参数，如:
            @mixin border-radius($radius:5px){
                -webkit-border-radius:$radius;
                border-radius:$radius
            }

    3.复杂的混合宏
        1.上面是一个简单的定义混合宏的方法，当然，Sass钟的混合宏还提供更为复杂的，你可以在大括号里面写上带有逻辑关系，帮助更好的做你想做的事情.如：
        @mixin box-shadow($shadow...){
            @if length($shadow) >= 1{
                @include prefixer(box-shadow,@shadow);
            }@else{
                @shadow:0 0 4px rgba(0,0,0,.3);
                @include prefixer(box-shadow,$shadow);
            }
        }