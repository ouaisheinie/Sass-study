<link type = "stylesheet" href="style/index.css">  这个是对的  CSS文件可以这样引用  但是sass 文件就不能这样引用了

<link type = "stylesheet" href="style/index.scss">
<link type = "stylesheet" href="style/index.scss">  这样引用sass 文件就是错的

在HTML文件里引用sass  需要先编译   先把sass 编译成css   然后 在html中引用

编译可以用  命令行工具   也可以用第三方软件   vscode 可以   


1. 安装sass   先安装ruby   目前选择在windows下    在命令行  sass -v  查看电脑是否安装sass

2.编译工具 
    1.命令行编译
    //单文件转换命令
    sass input.scss output output.css
    //单文件监听命令
    sass --watch input.scss:output.css
    //如果你有很多的sass文件的目录，你也可以告诉sass 监听整个目录
    sass --watch app/sass:public/stylesheets
    
    2.图形化编译   运用考拉来编译

    3.webstrom 的 file watcher   或者  VSCode的编译插件

3. sass 和 scss
    开发的时候 更推荐用scss  更接近css

4.变量
    sass里  变量以美元符号$来开头

5.编译错误
    sass或者scss 文件里  是默认utf-8编码    但是里面有中文字符  也会引起编译错误

6.sass不同样式风格的输出方法
    1.嵌套输出方式 nested
        1.sass提供了一种嵌套显示CSS文件的方法
                nav{
                    ul{
                        margin:0;
                        padding:0;
                        list-style:one;
                    }
                    li{display:inline-block;}
                    a{
                        display:block;
                        padding:6px 12px;
                        text-decoration:none;
                    }
                }

        -----上面的代码 编译的时候 带上参数 --style nested
        sass --watch test.scss:test.css --style nested
        编译出来就是如下

                nav ul {
                    margin: 0;
                    padding: 0;
                    list-style: none; }
                nav li {
                    display: inline-block; }
                nav a {
                    display: block;
                    padding: 6px 12px;
                    text-decoration: none; }
    2.展开输出方式 expanded
        跟上面输出一样   只是展开后 每个类的后面的"}"换到下一行了

            nav ul {
                    margin: 0;
                    padding: 0;
                    list-style: none; 
                    }
            nav li {
                    display: inline-block; 
                    }
            nav a{
                    display: block;
                    padding: 6px 12px;
                    text-decoration: none; 
                }
    2.紧凑输出方式 compact
        nav ul { margin: 0; padding: 0; list-style: none; }
        nav li { display: inline-block; }
        nav a { display: block; padding: 6px 12px; text-decoration: none; }
    4.压缩输出方式 compressed
        nav ul{margin:0;padding:0;list-style:none}nav li{display:inline-block}nav a{display:block;padding:6px 12px;text-decoration:none}


7.sass中的声明变量
    1.生命变量用美元符号$
    2.变量名称
    3.赋予变量的值
    4.!default 表示默认值  例如 $btn-primary-color:#fff !default;

8.普通变量与默认变量
    1.普通变量  定义之后可以在全局范围内使用
    $fontSize:12px;
    body{
        font-size:$fontSize;
    }

    2.默认变量 sass的默认变量仅需要在值后面加上!default即可
    $baseLineHeight:1.5 !default;
    body{
        line-height:$baseLineHeight;
    }
        1.默认变量的覆盖
        只需要在默认变量之前重新定义一下  例如
        $baseLineHeight: 2;
        $baseLineHeight: 1.5 !default;
        body{
            line-height: $baseLineHeight; 
        }
    ！！！！！默认变量的价值在进行组件化开发的时候非常有用。

9.sass变量的调用
    1.sass变量在声明之后 就可以在需要的地方调用变量了  调用变量的方法也非常简单
    就是类似之前我们一直都在调用着用了  哈哈哈哈

10.局部变量和全局变量
    sass里变量的作用在过去几年已经发生了一些改变。知道最近，规则集和其他范围内生命变量的作用于才被默认为本地。如果已经存在同名的全局变量，从3.4版本开始。sass已经可以正确处理作用域的概念，并通过创建一个新的局部变量来代替。
    例子：
    //scss
    $color:orange !default;
    //定义全局变量(在选择器，函数，混合宏..的外面定义的变量为全局变量)
    .block{
        color:$color;//调用全局变量
    }
    em{
        $color:red;//定义局部变量
        a{
            color:$color;调用的局部变量
        }
    }
    span{
        color:$color;//的调用的全局变量
    }

    sass还提供一个!global参数  
    !global 和 !default对于定义变量都是很有帮助的。
    我们之后将会详细介绍这两个参数的使用以及其功能。

    全局变量的影子
    当在局部范围(选择期内,函数内,混合宏内...)生命一个已经存在的全局范围内的变量时，局部变量变量就成为了全局变量的影子。“基本上，局部变量只会在局部范围内覆盖全局变量。”

    什么时候声明变量？
    创建变量只适用于感觉确有必要的情况下。不要为了某些骇客行为而声明变量，这些丝毫没有作用。只有满足所有下述标准时方可创建新变量：
        1.该值至少重复出现两次；
        2.该值至少可能会被更新一次；
        3.该值所有的表现都与变量有关(非巧合);
    基本上没有理由声明一个永远不需要更新或者只在单一地方使用的变量。

11.sass嵌套  选择器嵌套
    1.sass中也提供了选择器嵌套功能，但也并不意味着你在sass中的嵌套是无节制的，因为你嵌套的层级越深，编译出来的CSS代码的选择器层级将越深，这往往是大家不愿意看到的一点，这个特性正在被众多开发者滥用。

    2.选择器嵌套的样式表的作者提供了一个通过局部选择器互相嵌套实现全局选择的方法，Sass的嵌套分为三种：
        1.选择器嵌套
        2.属性嵌套
        3.伪类嵌套
    3.嵌套结构钟的 "&" 符号 代表当前作用于的嵌套集

12.sass嵌套  属性嵌套
    sass钟海提供属性嵌套:css有一些属性前缀相同，只是后缀不一样,比如border-top/border-right,与这个类似的还有margfin,padding,font等属性，假设你的样式中用到了
    .box{
        border-top:1px solid red;
        border-bottom:1px solid green;
    }
    在Sass中，我们可以把上面的代码这样写
    .box{
        border:{
            top:1px solid red;
            bottom:1px solid green;
        }
    }

13.sass嵌套  伪类嵌套
    1.其实伪类嵌套和属性嵌套非常类似，只不过它需要借助符号 "&"符号一起配合使用。我们就拿经典的clearfix为例
    .clearfix{
        $:before,
        $:after{
            content:"";
            display:table;
        }
        $:after{
            clear:both;
            overflow:hidden;
        }
    }
    上面的代码编译出来的CSS 为
    .clearfix:before,.clearfix:after{
        content:"";
        display:tabel;
    }
    .clearfix:after{
        clear:both;
        overflow:hidden;
    }
    但是我们应该避免选择器嵌套   显然 只有少数情况适应这一措施

14.混合宏 声明混合宏
    如果整个网站中有基础小样式类似，比如颜色或者字体等。在Sass可以使用变量来统一初六，那么这种选择还是不错的。当然你的样式越变越复杂，需要重复使用大段的样式时，使用变量就无法达到完美的目的了，这个时候Sass钟的混合宏就会变得非常有意义。
    下面主要介绍Sass中的混合宏

    1.声明混合宏
        不带参数混合宏
        在Sass中，使用"@mixin"来声明一个混合宏。如：
        @mixin border-radius{
            -webkit-border-radius:5px;
            border-radius:5px;
        }
        其中 @mixin 是用来声明混合宏的关键词,有点类似Css中的@media，@font-face一样。border-radius是混合宏的名称，大括号里面是复用的样式代码。

    2.带参数的混合宏
        1.除了声明一个不带参数的混合宏之外，还可以在定义混合宏时带有参数，如:
            @mixin border-radius($radius:5px){
                -webkit-border-radius:$radius;
                border-radius:$radius
            }

    3.复杂的混合宏
        1.上面是一个简单的定义混合宏的方法，当然，Sass钟的混合宏还提供更为复杂的，你可以在大括号里面写上带有逻辑关系，帮助更好的做你想做的事情.如：
        @mixin box-shadow($shadow...){
            @if length($shadow) >= 1{
                @include prefixer(box-shadow,@shadow);
            }@else{
                @shadow:0 0 4px rgba(0,0,0,.3);
                @include prefixer(box-shadow,$shadow);
            }
        }
        这是一个box-shadow的混合宏，带有多个参数，这个时候可以使用"..."来代替。简单的解释一下，当$shadow的参数数值大于或者等于1的时候，表示有多个阴影值，反之调用默认的参数值"0 0 4px rgba(0,0,0,.3)"
        注意:复杂的混合宏钟的逻辑关系(@if...@else)后面的小节会有讲解

15.sass混合宏-调用混合宏
    1.在Sass钟通过@mixin关键词声明了一个混合宏，那么在实际调用钟，其匹配了一个关键词"@include"来调用声明好的混合宏(如上面第14点里的);例如在你的样式中定义了一个圆角的混合宏"border-radius":
    @mixin border-radius{
        -webkit-border-radius:3px;
        border-radius:3px;
    }
    在一个按钮中药调用定义好的混合宏"border-radius",可以这样使用:
    button{
        @include border-radius;
    }
    这个时候编译出来的CSS就是如下
    button{
        -webkit-border-radius:3px;
        border-radius:3px;
    }

16.混合宏的参数--传一个不带值的参数
    1.Sass的混合宏有一个极其强大的功能，可以传参数，那么在Sass钟传参数主要有一下几种情形:
        1.传一个不带值的参数
            在混合宏中，可以传一个不带任何值的参数，比如：
            @mixin border-radius($radius){
                -webkit-border-radius:$radius;
                border-radius:$radius;
            }
            在混合宏"border-radius"中定义了一个不带任何值的参数"$radius"。
            在调用的时候可以给这个混合宏传一个参数值:
            .box{
                @include border-radius(3px);   //调用的时候给参数定值,haha
            }
            这里表示给混合混传递了一个 "border-radius"的值为 "3px".
            所以 编译出来的CSS 如下
            .box{
                -webkit-border-radius:3px;
                border-radius:3px;
            }
    2.传递一个带值的参数
        1.在Sass的混合宏钟，还可以给混合宏的参数传一个默认值，例如:
        @mixin border-radius($radius:3px){   //此处仅仅只是默认值  需要其他值 可以调用的时候给出
            -webkit-border-radius:$radius;
            border-radius:$radius;
        }
        在混合宏"border-radius"传了一个参数"$radius"，而且给这个参数赋予了一个默认值"3px".
        在调用类似这样的混合宏时，会多有一个机会，假设你的页面中的圆角很多地方都是3px的圆角，那么这个时候需要调用默认混合宏"border-radius"：
        .btn{
            @include border-radius;
        }
        编译出来的CSS
        .btn{
            -webkit-border-radius:3px;
            border-radius:3px;
        }
        但是有的时候，页面中有些元素的圆角值不一样，那么可以随机给混合宏传值，如:
        .box{
            @include border-radius(50%);//在调用的时候给出其他值
        }
        编译出来的CSS
        .box{
            -webkit-border-radius:50%;
            border-radius:50%;
        }

    3.传递多个参数
        1.Sass混合宏除了能传一个参数之外，还可以传递多个参数，如:
        @mixin center($width,$height){   //混合宏center  传递了多个参数(2个极以上)
            width:$width;
            height:$height;
            position:absolute;
            top:50%;
            left:50%;
            margin-top:-($height)/2;
            margin-left:-($width)/2;
        }
        实际调用和其他混合宏是一样的
        .box-center{
            @include center(500px,300px);
        }

        2.有一个特别的参数"..."。 当混合宏传的参数过多时，可以使用这个"..."来代替，例如
        @mixin box-shadow($shadow...){   //"..."参数
            @if length($shadow) >= 1{
                -webkit-box-shadow:$shadows;
                box-shadow:$shadows;
            } @else {
                $shadow: 0 0 2px rgba(#000,.25);
                -webkit-box-shadow:$shadow;
                box-shadow:$shadow;
            }
        }
        接下来是调用:
        .box{
            @include box-shadow(0 0 1px rgba(#000,.5),0 0 2px rgba(#000,.2));
        }
        编译出来的CSS：
        .box{
            -webkit-box-shadow:0 0 1px rgba(0,0,0,0.5),0 0 2px rgba(0,0,0,0.2);
            box-shadow:0 0 1px rgba(0,0,0,0.5),0 0 2px rgba(0,0,0,0.2);
        }

17.混合宏的参数--混合宏的不足
    1.混合宏在实际编码中给我们带来了很多方便之处，特别是对于复用重复代码块。但其最大的不足之处是会生成冗余的代码块。比如在不同的地方调用一个相同的混合宏时。如:
    @mixin border-radius{
        -webkit-border-radius:3px;
        border-radius:3px;
    }
    .box{
        @include border-radius;
        margin-bottom:5px;
    }
    .btn{
        @include border-radius;
    }
    编译出来的CSS如下
    .box{
        -webkit-border-radius:3px;
        border-radius:3px;
        margin-bottom:5px;
    }
    .btn{
        -webkit-border-radius:3px;
        border-radius:3px;
    }
    从以上可以看出 Sass在调用相同的混合宏时，并不能智能地将相同的样式的代码块合并到一起。这也是Sass的混合宏最不足之处

18.Sass的扩展和继承
    1.在Sass中也有继承依说，也是继承类中的样式代码块。在Sass中是通过关键词"@extend"来继承已经存在的类样式块，从而实现代码的继承，如下所示:
    //scss
    .btn{
        border:1px solid #ccc;
        padding:6px 10px;
        font-size:14px;
    }
    .btn-primary{
        background-color:#f36;
        color:#fff;
        @extend .btn;
    }
    .btn-second{
        background-color:orange;
        color:#fff;
        @extend .btn;
    }
    //编译出来之后 CSS
    .btn,.btn-primary,.btn-second{
        border:1px solid #ccc;
        padding:6px 10px;
        font-size:14px;
    }
    .btn-primary{
        background-color:#f36;
        color:#fff;
    }
    .btn-second{
        background-color:orange;
        color:#fff;
    }
    从代码中可以看出，在Sass中的继承，可以继承类样式块中所有样式代码，而且编译出来的CSS会将选择器合并在一起，形成组合选择器:
    .btn,.btn-primary,.btn-second{
        border:1px solid #ccc;
        padding:6px 10px;
        font-size:14px;
    }
    
19.Sass占位符 %placeholder
    Sass中的占位符 %placeholder功能是一个强大的，很实用的工程。它可以取代以前CSS中的基类造成的代码冗余的情形，因为%placeholder声明的代码，如果不被@extend调用的话，不会产生任何代码，来看一下:

    %mt5{
        margin-top:5px;
    }
    %pt5{
        padding-top:5px;
    }
    这段代码没有被@extend调用，其并没有产生任何代码块，只是静静地躺在你的某个SCSS文件中，只有通过@extend调用才会有代码产生：
    //scss
    %mt5{
        margin-top:5px;
    }
    %pt5{
        padding-top:5px;
    }
    .btn{
        @extend %mt5;
        @extend %pt5;
    }
    .block{
        @extend %mt5;

        span{
            @extend %pt5;
        }
    }
    编译出来的CSS
    .btn,.block{
        margin-top:5px;
    }
    .btn,.block span{
        padding-top:5px;
    }